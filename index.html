<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Technical Documentation</title>
    <link rel="stylesheet" href="styles/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet">
</head>

<body>
    <header>
        <h1>Python Documentation</h1>
        <div id="arrow-list">&#9660;</div>
        <nav id="navbar">
            <a href="#numbers" class="nav-link">Numbers</a>
            <a href="#strings" class="nav-link">Strings</a>
            <a href="#lists" class="nav-link">Lists</a>
            <a href="#if_statements" class="nav-link">if Statements</a>
            <a href="#for_statements" class="nav-link">for Statements</a>
            <a href="#the_range()_function" class="nav-link">The range() Function</a>
            <a href="#intermezzo:_coding_style" class="nav-link">Intermezzo: Coding Style</a>
            <a href="#reference" class="nav-link">Reference</a>
        </nav>
    </header>

    <main id="main-doc">
        <section class="main-section" id="numbers">
            <h2>Numbers</h2>
            <p>
                The interpreter acts as a simple calculator: you can type an expression at it and it will write the
                value.
                Expression syntax is straightforward: the operators +, -, * and / work just like in most other languages
                (for example Pascal or C); parentheses (()) can be used for grouping.
            </p>
            <pre> 2 + 2
                4
                50 - 5*6
                20
                (50 - 5*6) / 4
                5.0
                8 / 5 # division always returns a floating point number
                1.6
            </pre>

            <p>
                The integer numbers (e.g. 2, 4, 20) have type int, the ones with a fractional part (e.g. 5.0, 1.6) have
                type
                float. We will see more about numeric types later in the tutorial.
            </p>
            <p>
                Division (/) always returns a float. To do floor division and get an integer result (discarding any
                fractional
                result) you can use the // operator; to calculate the remainder you can use %:
            </p>
            <pre>17 / 3 # classic division returns a float
                5.666666666666667
                17 // 3 # floor division discards the fractional part 
                5 
                17 % 3 # the % operator returns the remainder of the division 
                2 
                5 * 3 + 2 # floored quotient * divisor + remainder 
                17
            </pre>

            <p>
                If a variable is not “defined” (assigned a value), trying to use it will give you an error:
            </p>
            <pre>>>> n # try to access an undefined variable 
            Traceback (most recent call last): 
            File &lt;stdin&gt;, line 1, in &lt;module&gt; 
            NameError: name 'n' is not defined
      </pre>

            <p>
                There is full support for floating point; operators with mixed type operands convert the integer operand
                to
                floating point:
            </p>
            <pre>4 * 3.75 - 1 
                14.0
            </pre>

            <p>
                In addition to int and float, Python supports other types of numbers, such as Decimal and Fraction.
                Python also
                has
                built-in support for complex numbers, and uses the j or J suffix to indicate the imaginary part (e.g.
                3+5j).
            </p>
        </section>

        <section class="main-section" id="strings">
            <h2>Strings</h2>
            <p>
                Besides numbers, Python can also manipulate strings, which can be expressed in several ways. They can be
                enclosed in single quotes ('...') or double quotes ("...") with the same result 2. \ can be used to
                escape
                quotes:
            </p>
            <pre>'spam eggs' # single quotes 
                'spam eggs' 
                'doesn\'t' # use \' to escape the single quote... 
                "doesn't" 
                "doesn't" # ...or use double quotes instead 
                "doesn't" 
                '"Yes," they said.' 
                '"Yes," they said.' 
                "\"Yes,\" they said." 
                '"Yes," they said.' 
                '"Isn\'t," they said.' 
                '"Isn\'t," they said.'
            </pre>

            <p>
                Strings can be concatenated (glued together) with the + operator, and repeated with *:
            </p>
            <pre># 3 times 'un', followed by 'ium' 
                 3 * 'un' + 'ium' 
                'unununium'
            </pre>
            <p>
                Two or more string literals (i.e. the ones enclosed between quotes) next to each other are automatically
                concatenated.
            </p>
            <pre>'Py' 'thon' 
                'Python'
            </pre>

            <p>
                Strings can be indexed (subscripted), with the first character having index 0. There is no separate
                character type; a
                character is simply a string of size one:
            </p>
            <pre>word = 'Python' 
                word[0] # character in position 0 
                'P' 
                word[5] # character in position 5 
                'n'
            </pre>

            <p>
                Indices may also be negative numbers, to start counting from the right:
            </p>
            <pre>word[-1] # last character 
                'n' 
                word[-2] # second-last character 
                'o' 
                word[-6] 
                'P'
            </pre>

            <p>
                Note that since -0 is the same as 0, negative indices start from -1.
            </p>
            <p>
                In addition to indexing, slicing is also supported. While indexing is used to obtain individual
                characters, slicing
                allows you to obtain substring:
            </p>
            <pre>word[0:2] # characters from position 0 (included) to 2 (excluded) 
                'Py' 
                word[2:5] # characters from position 2 (included) to 5  (excluded) 
                'tho'
            </pre>

            <p>
                One way to remember how slices work is to think of the indices as pointing between characters, with the
                left edge of the
                first character numbered 0. Then the right edge of the last character of a string of n characters has
                index n, for
                example:
            </p>
            <pre>+---+---+---+---+---+---+
                | P | y | t | h | o | n | 
                +---+---+---+---+---+---+ 
                0 - 1 - 2 - 3 - 4 - 5 -  6 
                -6 -5 &nbsp;-4 &nbsp;-3 &nbsp;-2 &nbsp;-1 
            </pre>

            <p>
                Python strings cannot be changed — they are immutable. Therefore, assigning to an indexed position in
                the string results in an error:
            </p>
            <pre>word[0] = 'J'
                Traceback (most recent call last):
                File "stdin", line 1, in module
                TypeError: 'str' object does not support item assignment
                word[2:] = 'py'
                Traceback (most recent call last):
                File "stdin", line 1, in module
                TypeError: 'str' object does not support item assignment
            </pre>

            <p>
                If you need a different string, you should create a new one:
            </p>
            <pre>'J' + word[1:]
                'Jython'
                word[:2] + 'py'
                'Pypy'
            </pre>

            <p>
                The built-in function len() returns the length of a string:
            </p>
            <pre>s = 'supercalifragilisticexpialidocious'
                len(s)
                34
            </pre>
        </section>

        <section class="main-section" id="lists">
            <h2>Lists</h2>
            <p>
                Python knows a number of compound data types, used to group together other values. The most versatile is
                the
                list, which
                can be written as a list of comma-separated values (items) between square brackets. Lists might contain
                items
                of
                different types, but usually the items all have the same type.
            </p>
            <pre> squares = [1, 4, 9, 16, 25]
                squares
                [1, 4, 9, 16, 25]
            </pre>

            <p>
                Like strings (and all other built-in sequence types), lists can be indexed and sliced:
            </p>
            <pre>>>> squares[0] # indexing returns the item
                1
                squares[-1]
                25
                squares[-3:] # slicing returns a new list
                [9, 16, 25]
            </pre>

            <p>
                All slice operations return a new list containing the requested elements. This means that the following
                slice
                returns a
                shallow copy of the list:
            </p>
            <pre>>>> squares[:]
                [1, 4, 9, 16, 25]
            </pre>

            <p>
                Lists also support operations like concatenation:
            </p>
            <pre>squares + [36, 49, 64, 81, 100]
                [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
            </pre>

            <p>
                Unlike strings, which are immutable, lists are a mutable type, i.e. it is possible to change their
                content:
            </p>
            <pre>cubes = [1, 8, 27, 65, 125] # something's wrong here
                4 ** 3 # the cube of 4 is 64, not 65!
                64
                cubes[3] = 64 # replace the wrong value
                cubes
                [1, 8, 27, 64, 125]
            </pre>

            <p>
                You can also add new items at the end of the list, by using the append() method
            </p>
            <pre>cubes.append(216) # add the cube of 6
                cubes.append(7 ** 3) # and the cube of 7
                cubes
                [1, 8, 27, 64, 125, 216, 343]
            </pre>

            <p>
                Assignment to slices is also possible, and this can even change the size of the list or clear it
                entirely:
            </p>
            <pre>letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
                letters
                ['a', 'b', 'c', 'd', 'e', 'f', 'g']
                # replace some values
                letters[2:5] = ['C', 'D', 'E']
                letters
                ['a', 'b', 'C', 'D', 'E', 'f', 'g']
                # now remove them
                letters[2:5] = []
                letters
                ['a', 'b', 'f', 'g']
                # clear the list by replacing all the elements with an empty list
                letters[:] = []
                letters
                []
            </pre>
        </section>

        <section class="main-section" id="if_statements">
            <h2>if Statements</h2>
            <p>
                There can be zero or more elif parts, and the else part is optional. The keyword ‘elif’ is short for
                ‘else if’,
                and is
                useful to avoid excessive indentation. An if … elif … elif … sequence is a substitute for the switch or
                case
                statements
                found in other languages.
            </p>
            <pre>x = int(input("Please enter an integer: "))
                if x &lt; 0: 
                x=0 
                print('Negative changed to zero') 
                elif x==0: 
                print('Zero') 
                elif x==1: 
                print('Single') 
                else: 
                print('More')
            </pre>
        </section>

        <section class="main-section" id="for_statements">
            <h2>for Statements</h2>
            <p>
                The for statement in Python differs a bit from what you may be used to in C or Pascal. Rather than
                always
                iterating over
                an arithmetic progression of numbers (like in Pascal), or giving the user the ability to define both the
                iteration step
                and halting condition (as C), Python’s for statement iterates over the items of any sequence (a list or
                a
                string), in
                the order that they appear in the sequence. For example (no pun intended):
            </p>
            <pre># Measure some strings:
                words = ['cat', 'window', 'defenestrate']
                for w in words:
                print(w, len(w))
            </pre>

            <p>
                Code that modifies a collection while iterating over that same collection can be tricky to get right.
                Instead,
                it is
                usually more straight-forward to loop over a copy of the collection or to create a new collection:
            </p>
            <pre># Strategy: Iterate over a copy
                for user, status in users.copy().items():
                if status == 'inactive':
                del users[user]
        
                # Strategy: Create a new collection
                active_users = {}
                for user, status in users.items():
                if status == 'active':
                active_users[user] = status
            </pre>
        </section>

        <section class="main-section" id="the_range()_function">
            <h2>The range() Function</h2>
            <p>
                If you do need to iterate over a sequence of numbers, the built-in function range() comes in handy. It
                generates
                arithmetic progressions:
            </p>
            <pre>for i in range(5):
                print(i)
                0
                1
                2
                3
                4
            </pre>

            <p>
                The given end point is never part of the generated sequence; range(10) generates 10 values, the legal
                indices
                for items
                of a sequence of length 10. It is possible to let the range start at another number, or to specify a
                different
                increment
                (even negative; sometimes this is called the ‘step’):
            </p>
            <pre>list(range(5, 10))
                [5, 6, 7, 8, 9]
                
                list(range(0, 10, 3))
                [0, 3, 6, 9]
    
                list(range(-10, -100, -30))
                [-10, -40, -70]
            </pre>

            <p>
                To iterate over the indices of a sequence, you can combine range() and len() as follows:
            </p>
            <pre>a = ['Mary', 'had', 'a', 'little', 'lamb']
                for i in range(len(a)):
                print(i, a[i])
                0 Mary
                1 had
                2 a
                3 little
                4 lamb
            </pre>
        </section>

        <section class="main-section" id="intermezzo:_coding_style">
            <h2>Intermezzo: Coding Style</h2>
            <p>
                For Python, <a href="https://www.python.org/dev/peps/pep-0008/" rel="noopener" target="_blank">PEP 8</a>
                has emerged as the style guide that most
                projects adhere to; it promotes a very readable and
                eye-pleasing coding style. Every Python developer should read it at some point; here are the most
                important points
                extracted for you:
            </p>
            <ul>
                <li>Use 4-space indentation, and no tabs.<br>
                    4 spaces are a good compromise between small indentation (allows greater nesting depth) and large
                    indentation (easier to
                    read). Tabs introduce confusion, and are best left out.</li>
                <li>Wrap lines so that they don’t exceed 79 characters.<br>
                    This helps users with small displays and makes it possible to have several pre files side-by-side
                    on larger displays.</li>
                <li>Use blank lines to separate functions and classes, and larger blocks of pre inside functions.</li>
                <li>When possible, put comments on a line of their own.</li>
                <li>Use docstrings.</li>
                <li>Use spaces around operators and after commas, but not directly inside bracketing constructs: a =
                    f(1, 2) + g(3, 4).</li>
                <li>Name your classes and functions consistently; the convention is to use UpperCamelCase for classes
                    and
                    lowercase_with_underscores for functions and methods. Always use self as the name for the first
                    method argument (see <a href="https://docs.python.org/3/tutorial/classes.html#tut-firstclasses"
                        rel="noopener" target="_blank">A
                        First Look at Classes</a>
                    for more on classes and methods).</li>
                <li>Don’t use fancy encodings if your pre is meant to be used in international environments. Python’s
                    default, UTF-8, or
                    even plain ASCII work best in any case.</li>
                <li>Likewise, don’t use non-ASCII characters in identifiers if there is only the slightest chance people
                    speaking a
                    different language will read or maintain the pre.</li>
            </ul>
        </section>

        <section class="main-section" id="reference">
            <h2>Reference</h2>
            <p>
                All the documentation in this page is taken from <a href="https://docs.python.org/3/tutorial/index.html"
                    rel="noopener" target="_blank">The Python Tutorial</a>
            </p>
        </section>
    </main>

    <aside></aside>

    <footer></footer>
    <script src="scripts/scripts.js"></script>
</body>

</html>